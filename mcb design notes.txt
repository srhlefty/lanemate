DDR clock is 400 MHz (2.5 ns period)
Trace length from FPGA to DIMM slot is about 5.1 inch
Rule of thumb is 150 ps/inch propagation speed
Total there-and-back delay is therefore 0.15 * 10.2 = 1.53 ns

Since I will not be using DQS to capture read data (is this a hard req?),
I need to delay the received data enough to properly capture it.

Yes, I can't use DQS to capture the data. In principle the technique is
viable, but the issue here is that the DQS lines are not on clock pins.
In fact there aren't enough clock pins even in principle.

This means I must do a "blind" data capture using my FPGA-generated clocks.

There are two stages of calibration: write leveling and read leveling.

Before doing DDR3 write leveling, the ram must be initialized. Why doesn't
leveling affect initialization? Because of the routing topology. Of the 
control signals, only DQS is *not* routed fly-by to each lane, because there
is a separate DQS for each lane. Initialization does not use DQS nor DQ.

Write leveling is done by successively delaying DQS and monitoring DQ for
a transition from 0 to 1. The value of this output delay should then be
applied to the data lines as well. And of course this needs to be done
for each byte lane since there is one DQS per lane. (The chip samples the
clock using DQS as the clock.) This process does not require that reading be 
fully correct: DQ is clocked by DQS, so it does not change until the next DQS. 
Reading the value of DQ can thus take place "some time later" without regard to 
bit alignment or skew.

Note that the output delay in the IODELAY block is a compile-time constant. So I
cannot do write leveling programmatically. I will need to make a new bit file
for each unique tap value.



Ok so here is the order of operations:

1. Write initialization code. All these operations use the control lane, which
is routed to be tightly length matched. The lines are also routed fly-by to
each chip, so they will all eventually get the message.

2. Perform write leveling for each lane. Sequence is power up, initialization,
then write appropriate register to enable write leveling. Pipe the DQ bit out
to a GPIO LED. Send DQS pulses every 10ish system clocks. View the LED or probe
the pin for each tap value. Note the delay values when the LED changes state.
The maximum amount of time DQS can be early is one half-period, 1250 ps.

Taps	Estimated delay (ps)
0		0 			= 0
1		8			= 8
2		40			= 40
3		95			= 95
4		108			= 108
5		171			= 171
6		207			= 207
7		212			= 212
8		322			= 322
9		1*322+8		= 330
10		1*322+40	= 362
11		1*322+95	= 417
12		1*322+108	= 430
13		1*322+171	= 493
14		1*322+207	= 529
15		1*322+212	= 534
16		2*322		= 644
17		2*322+8		= 652
18		2*322+40	= 684
19		2*322+95	= 739
20		2*322+108	= 752
21		2*322+171	= 815
22		2*322+207	= 851
23		2*322+212	= 856
24		3*322		= 966
25		3*322+8		= 974
26		3*322+40	= 1006
27		3*322+95	= 1061
28		3*322+108	= 1074
29		3*322+171	= 1137
30		3*322+207	= 1173
31		3*322+212	= 1178
32		4*322		= 1288

On-board trace lengths
Clock:  5.100"
Lane 0: 5.359" (+0.259)
Lane 1: 5.210" (+0.110)
Lane 2: 5.050" (-0.050)
Lane 3: 5.110" (+0.010)
Lane 4: 5.110" (+0.010)
Lane 5: 5.110" (+0.010)
Lane 6: 5.110" (+0.010)
Lane 7: 5.154" (+0.054)

But since clock is routed fly-by, it travels extra distance before reaching the 
actual lane. Clock arrives in the middle of the connector, so let's assume that
it first travels to the lane 0 edge, then travels across to lane 7. Further
assume that there are 4.5/7 = 0.64 inches between each ram chip. The clock then
travels 4.5/2 = 2.25" to the right edge, then 0.64" to each successive chip.

Total signal travel length (estimated):
        Clock                                      DQS
Lane 0: 5.100 + 2.25 + 0*0.64 =  7.35" = 1103ps    5.359" = 804ps
Lane 1: 5.100 + 2.25 + 1*0.64 =  7.99" = 1199ps    5.210" = 782ps
Lane 2: 5.100 + 2.25 + 2*0.64 =  8.63" = 1295ps    5.050" = 758ps
Lane 3: 5.100 + 2.25 + 3*0.64 =  9.27" = 1391ps    5.110" = 767ps
Lane 4: 5.100 + 2.25 + 4*0.64 =  9.91" = 1487ps    5.110" = 767ps
Lane 5: 5.100 + 2.25 + 5*0.64 = 10.55" = 1583ps    5.110" = 767ps
Lane 6: 5.100 + 2.25 + 6*0.64 = 11.19" = 1679ps    5.110" = 767ps
Lane 7: 5.100 + 2.25 + 7*0.64 = 11.83" = 1775ps    5.154" = 773ps

Subtracting those two columns gives us the estimated DQS delay for each lane:
Lane 0:  299ps
Lane 1:  417ps
Lane 2:  537ps
Lane 3:  624ps
Lane 4:  720ps
Lane 5:  816ps
Lane 6:  912ps
Lane 7: 1001ps

Bringup notes:
- No LEDs ever lit with any of the tap delays.
- I checked that DQS is making it to the connector.
- I checked that different tap values do move DQS.
- I checked that the clock does not move with DQS tap setting.
- Instead of write leveling, I changed modes to perform the read leveling step.
  Provided the DRAM chip received my read request, I should see DQS pulses even
  if the read leveling was not successfully enabled.
- I did not see DQS pulses! Therefore the DRAM chip is not seeing the command.
- I lowered the frequency by a factor of 4 to make it easier to look at the
  clock/data phase relationship at the connector. Definitely not what it showed
  in the simulator! I had to move the clock to 0 degrees and command bus to 180 
  degrees to get the command appropriately positioned relative to the clock.
- Now I get DQS pulses!
- Switched back to write leveling. Adjusted the phase so that clock and DQS
  have 0 delay to start. 0 taps: none. 32 taps: lane 0! 16: none. 24: none.
  28: none. 30: none. 31: lane 0. So 31 is the minimum for lane 0. According to
  the spec (tDQSCK) the window of allowed DQS-CK skew is +/-225ps for the 
  fastest speed grade. The difference between 30 and 31 taps is only predicted
  to be 5 ps. Between 31 and 32 is 110 ps. So I'm well within that window. These
  tap results should be valid for faster frequencies too, because I began with
  clock and DQS at the same phase out of the PLL.
- Upped the frequency by a factor of 2 (now 100Mhz sysclk, 400MHz ioclk).
  Lane 0 light now unlit. 64 taps: still nothing.
- Tried going back to the read test with the faster clock. Alignment of CAS to
  clock looks ok, but no DQS pulses. Maybe this is a signal integrity issue?
  It's tempting to blame that because I really can't do anything about it.
- Back to the slow clock with read test. Now I don't get DQS pulses???
- Messing around with constraints to have the compiler tell me what the skew
  is across all the ram nets. I also realized I had forgotten to adjust the
  phase of the bank, address, and data pins after the initial discovery.
  The report says that the skew for the different-bank outputs is really bad,
  as much as 4ns.
- Now I'm getting all 8 lanes to light up in read test mode with zero delay!!!
- All lanes ok at 100MHz/400MHz
- Switched back to 50/200 and turned on write leveling (0 taps). Lanes 5,6,7 on.
  Does that mean there's so much skew that those lanes are falling into the
  previous clock? I looked at the timing report, and lanes 5,6,7 are reported
  to have a DQS-CK skew of 3.2ns relative to CK0. DQSP4, which is on the same
  bank as CK0, has a skew of 0. 
- I tried adding some taps of delay and reran the report. The skew was properly
  updated! Good, this means that I can use the tap delay feature on each pin to
  try to remove these cross-bank delays. But I found a Xilinx forum post that
  suggested there is no problem clocking multiple banks simultaneously with just
  minimal delay--why are DQSP 5,6,7 so delayed then? And can I tell the tool
  somehow that I want the bus skew to be less than a certain amount?
- Report says DQS7 should have a skew of 2.7ns relative to DQS0. Measured on the
  scope, it looks like 1.3ns to me.
  
- Lots of reading suggests that the best you can do in terms of skew is FF at
  the chip edge (or I/OSERDES) all driven by the same clock. I made a test
  project with the SYSCLK, CK0_P, and DQSP nets assigned to their proper pins.
  (These span all 4 banks). I manually instantiated an ODDR for each output,
  and drove them all with the same clock. The timing report indicated a max
  skew of 0.173ns. So my issue might be coming from my desire to use the high
  speed dedicated route, which requires the use of those chained PLLs.

- Ok so I was wrong that I had to use chained PLLs. It turns out that the
  restriction is *not* that a PLL can only drive one bank--it's that a BUFPLL
  can only drive one bank. And it further turns out that the same PLL output
  can drive multiple BUFPLLs! I now have each PLL output driving 3 BUFPLLs,
  one for each bank. The max reported skew across CK and DQS is now just 0.2ns.
  
- Since clock skew changed a bunch, I turned on read leveling to look at how
  command's edge related to clock at the connector. The phase looks correct.
  All LEDs light even with zero delay (probably by accident). In write leveling,
  DQS0 was aligned really well with clock.
  
- Successful write leveling! Tap values 22,29,34,37,34,48,54,54.
- I tried upping the frequency to the original 200/800. Lanes 0,1,2,4 still
  work but the others don't. I tried some exaggerated tweaking of delays but
  never got those to light up. I tried 150/300, and all but lanes 6,7 work. But
  5,4,3 were metastable. Adding some taps of delay to 6 & 7 did not fix it.
  The next one down is 125/500: 3 and 4 were metastable but the others were ok.
  I added a few taps to them and it fixed it, all stable. So let's stick with
  that clock for now. Taps: 22,29,34,39,35,48,54,54.
  

3. Configure each lane's OSERDES with the proper tap value. Verify that in write
leveling mode, all lane's LEDs light up. Remember that the spec says that DQS
on write should be _aligned_ to CK, so pick the delay value that first causes
the DQ transition.

4. Read leveling is trickier. There are two stages: getting the data centered
on the clock edges, and bitslip. The results of the write leveling should tell
me the amount of extra clock propagation delay for each lane. Since data is
returned aligned to the clock edge, the data edge will be delayed by the amount
of clock propagation delay. I can then use that number to determine how much
extra delay is needed to push each lane into the center. Next is the bitslip
routine. I configure the DIMM to emit known data and perform a bitslip until
I get the correct value. If it fails, then I'm either capturing on the wrong
clock cycle or the data is not properly centered on the clock edges.


- Now that I have done write leveling, I need to move DQS to the 180 deg clock
  like the command and data. This is because during a write command, I must
  provide DQS center-aligned to the clock, just like I must provide data
  center-aligned to the clock.
